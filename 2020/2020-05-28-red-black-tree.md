<!---
markmeta_author: wongoo
markmeta_date: 2020-05-28
markmeta_title: 红黑树
markmeta_categories: algriothm
markmeta_tags: tree
-->

# 红黑树


## 1. 二叉搜索树

- 定义: 
	- 二叉搜索树: 左子节点下的所有所节点均小于当前节点, 右子节点下的所有节点均大于当前节点；
	- 前驱节点: 左子树中小于当前节点的最大值节点, 二叉树先取左节点, 然后再一直取右节点，直到叶子节点即为前驱节点；
	- 后驱节点: 右子树中大于当前节点的最小值节点, 二叉树先取右节点, 然后再一直取左节点，直到叶子节点即为后驱节点；
- 特点:
	- 算法实现简单
	- 树的高度不固定，依赖于构建树的顺序，最差的情况变成了链表（时间复杂度 O(n)）
- 操作: 
	- 查找: 从根节点往下依次判断查找
	- 插入: 从根节点开始往下查找到叶子节点位置插入
	- 删除: 首先找到待删除的节点，然后找到待删除节点的后驱节点（或前驱节点）并与之交换位置，待删除节点就移到了叶子节点位置，删除该节点； 如果该删除节点有子节点，将其子节点挂到其父节点下。



## 2. 2-3 树（平衡搜索树）

- 定义: 
	- 2-3树: 一个节点可以包含一个或两个值, 节点有1个值的情况该节点有2个子节点，即2叉； 节点有2个值的情况该节点有3个子节点，即3叉；
	- 2叉节点: 包含1个值，有2个子节点；
	- 3叉节点: 包含2个值, 有3个子节点；
	- 4叉节点: 包含3个值, 有4个子节点，但这样的节点只是临时节点，通过平衡后消除；
	- 前驱元/后驱元: 这里名称不用**节点**，是因为一个节点可能有两个值，前驱元/后驱元只是表示其中一个值；
- 特点:
	- 树始终保持平衡（从根节点到叶子节点的高度始终一致），查找/增加/删除 的平均复杂度为 O(lgN)
	- 算法实现复杂： 节点类型有两种，需要来回变换节点类型； 节点的搜索方向也分2叉和三叉； 节点旋转的场景多样；
- 操作: 
	- 查找: 从根节点往下依次判断查找，3叉节点可能要进行两次判断才能确定子节点；
	- 插入: 
		- 插入算法：
			1. 从根节点往下找到叶子节点位置插入；
			2. 如果叶子节点是2叉节点，将新值加入该叶子节点，使其变为3叉节点,插入结束；
			3. 如果叶子节点是3叉节点，将新值加入该叶子节点，使其变为4叉节点，需要进行以下平衡算法；
		- 插入后平衡算法(**基本思想: 推举4叉节点的中位元一层层升级，使树达到平衡，直至根节点**)：
			1. 对于4叉节点，将其3个值中的中间值上移到父节点, 使4叉节点变为3叉节点；
			2. 如果父节点变为4叉节点，继续将中间值上移一直到根节点；
			3. 根节点变为4叉节点，上移中间值成为新的根节点（树高度加1）；
	- 删除: 
		- 删除算法: 
			1. 从根节点往下找到待删除元位置；
			2. 找到待删除元的后驱元（或前驱元）；
			3. 交换待删除元和后驱元位置，待删除元即位于叶子节点，将其删除;
			4. 如果删除位置的叶子节点是3叉节点，删除后变为2叉节点，删除动作结束；
			5. 如果删除位置的叶子节点（后面用N表示）是2叉节点，删除后该子节点整个被删除，需要进行以下平衡；

		- 删除平衡算法（**基本思想: 通过向兄弟节点、父节点借值来平衡删除的节点，如果父节点不够，一层层往上借直至根节点**）
			1. 如果N的兄弟节点有3叉节点，则通过旋转，将父节点一个值下移替代被删除的节点N，兄弟节点中的一个值上移成为新的父节点，使得树重新平衡；
			2. 如果N的兄弟节点只有2叉节点，父节点是3叉节点，下移父节点一个值替代被删除节点N，使父节点变为2叉节点，使得树重新平衡；
			3. 如果N的兄弟节点只有2叉节点，父节点是2叉节点，将父节点下移替代N，以父节点为N继续1 、2、3步检查，直至根节点；
			4. 如果根节点也已下移，则下移后的节点成为新的根节点（树高度减1）；



## 3. 2-3-4 树 (平衡搜索树)

- 定义: 在2-3树基础上，再增加一种4叉节点；
- 特点: 因为增加了一种节点类型，算法实现上比2-3树更为复杂；查找/增加/删除 的平均复杂度为 O(lgN)
- 操作: 类似2-3树，但插入平衡算法稍有差异，2-3树插入得到4叉节点后将其平衡掉； 2-3-4树是先平衡掉叶子节点中的4叉节点后再插入新值（因为变为5叉节点后再平衡会导致出现一个节点有两个中值，从而无法判断到底要将哪一个值上移，增加算法复杂度）；


## 4. 左倾红黑树(left-lean red black tree)

- 定义:
	- 左倾红黑树是 2-3树的二叉树表示方式， 左倾红黑树可以和2-3树一一对应；
	- 对于2-3树中的3叉节点中的两个值，大值作为左倾红黑二叉树中的父节点，小值作为左节点，两个节点之间用红色进行连线（通常将颜色标记在左子节点上）
- 特点:
	- 红色连线都位于左子树；
	- 不会出现相邻的两条红色连线，否则就出现2-3-4树中的4叉节点，这也意味着红色连线总数被黑色连线分割开的；
	- 最高的子树高度不会超过最低子树高度的2倍；因为2-3树所有子树高度一致，转换为左倾红黑树后，最多出现左侧节点都是3叉节点，而右侧都是2叉节点，左侧3叉节点变为2叉树节点后，高度翻倍；
	- 如果将左倾红黑树中的红色连线画平，树的高度和2-3树一致；
	- 算法实现变得简单： 
		- 节点类型变为单一的节点，减少了数据结构定义的复杂度；
		- 原来节点的上下移动的逻辑很复杂，现在变为二叉树的左旋右旋操作，实现更简单；
		- 原来维护节点的类型变化，改为维护红色连线不相邻的规则逻辑；
	- 虽然左倾红黑树的平衡动作可以和2-3树中的所有操作一一对应，但数据结构的定义更简单，对于用户更易理解；


## 5. 红黑树(red black tree)

- 定义:
	- 2-3-4树的 二叉树表示方式;
	- 相比于左倾红黑树，其允许左右子节点均为红色连线（通常将颜色标记在左子树上）

- 性质:
	1. 节点是红色或黑色（将颜色标记到节点上）
	2. 根是黑色。（因为关联的节点都来自于子节点）
	3. 所有叶子都是黑色（叶子是nil节点）（便于统计路径上黑色节点数）
	4. 每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点，黑色节点将红色节点分隔开）
	5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（对应2-3-4树的所有路径树高度一致）

- 特点:
	- 红黑树也是平衡树
	- 最高的子树高度不会超过最低子树高度的2倍（同左倾红黑树）
	- 逻辑结构相比2-3-4树更简单，算法易实现，性能也会更好；
	- 相比左倾红黑树，树的高度会更低（允许左右均为红节点），性能更好；

- 算法描述代号说明: N 为当前待平衡节点， S 为 N 的兄弟节点 , P 为 N 的父节点， PP 为 N 的祖父节点

- 插入操作:
	- 插入算法: 找到正确叶子节点位置插入，新插入节点为红色，然后进行平衡算法；
	- 插入后平衡算法:
		- 基本思想： 将增加红节点导致的两个连续的红节点一层层往上消除，过程中始终保持子树左右黑色节点数一致；
		- 平衡算法:
			1. 如果P是黑色，则结束平衡；
			2. 如果到根节点，将根节点设置为黑色，平衡结束；
			3. P为红色(PP即为黑色), S为红色, ,则设置P,S为黑色, 设置 PP为红色，将N设置为PP节点，继续平衡操作；
			4. P是红色(PP即为黑色), S为黑色, 但N和P不在同一个子节点方向（一个左节点、一个右节点），则旋转N为P的父节点（P变为N的子节点），使得N,P处在相同的子节点方向，现在则满足以下第5种情况；
			5. P是红色(PP即为黑色), S为黑色, N和P处在同一个子节点方向（都为左节点或都是右节点）， 则设置P为黑色，PP为红色，向上旋转P作为PP的父节点；结果是通过P的黑色节点数都一致了（没增加没减少），且消除了连续两个红色节点。平衡结束。

- 删除操作: 
	- 删除操作算法：
		1. 找到待删除节点 N；
		2. 找到待删除节点的后驱节点，和待删除节点进行值交换, 待删除节点 N 变为到了叶子节点位置；
		3. 删除 N 节点（N可能存在一个子节点或不存在子节点）；
			- 如果 N 不存在 子节点
				- N 为红色, 删除N，结束
				- N 为黑色，删除N，设置 N 为 N 的父节点, 进行删除后平衡
			- 如果 N 存在子节点 C，
				- N 为红色, C 为黑色，设置 C 值到 N，设置 N 为黑色, 删除 C， 结束；
				- N 为黑色, C 为红色, 设置 C 值到 N，删除 C， 结束；
				- N 为黑色, C 为黑色, 设置 C 值到 N, 删除 C, 进行删除后平衡

	- 删除后平衡算法
		- 基本思想：
			- 需要平衡是因为待平衡子树黑色节点数少了1；
			- 通过局部变换，左右旋转及颜色变换，在保证兄弟子树的黑色节点数不变的情况下，增加删除节点子树的黑色节点数；
			- 如果无法满足上面的情况，则将左右子树的黑色节点数调整为一致，再在父节点基础上做以上平衡操作，直至根节点；

		- 情形1: 
			- 前提: N是新的根。
			- 执行: 就做完了。
			- 结果: 从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。

		- 情形2： 
			- 前提: S是红色。
			- 执行: 在N的父亲上做左旋转，把红色兄弟转换成N的祖父，接着对调N的父亲和祖父的颜色。
			- 结果: 完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以可以接下去按情形4、情形5或情形6来处理。

		- 情形3： 
			- 前提: N的父亲P、S和S的儿子都是黑色的。
			- 执行: 重绘S为红色。
			- 结果: 结果是通过S的所有路径，它们就是以前不通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，要从情形1开始，在P上做重新平衡处理。

		- 情形4： 
			- 前提: S和S的儿子都是黑色，但是N的父亲P是红色。
			- 执行: 交换S和P的颜色。
			- 结果: 这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。

		- 情形5： 
			- 前提: S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子。
			- 执行: 在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟， 接着交换S和它的新父亲的颜色。
			- 结果: 所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，他的右儿子是红色的，所以进入了情形6。N和它的父亲都不受这个变换的影响。

		- 情形6： 
			- 前提: S是黑色，S的右儿子是红色，而N是它父亲的左儿子。
			- 执行: 在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。接着交换N的父亲和S的颜色，并使S的右儿子为黑色。
			- 结果: 子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先：要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。


## 参考

- https://www.cs.drexel.edu/~amd435/courses/cs260/lectures/L-6_2-3_Trees.pdf
- https://zh.wikipedia.org/zh/%E7%BA%A2%E9%BB%91%E6%A0%91
- https://github.com/wongoo/goalg/blob/master/tree/rbtree/rbtree.go

